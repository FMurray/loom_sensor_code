

const	   BME280_ADDRESS					   = 0x77;

const      BME280_REGISTER_DIG_T1              = "\x88";
const      BME280_REGISTER_DIG_T2              = "\x8A";
const      BME280_REGISTER_DIG_T3              = "\x8C";
const      BME280_REGISTER_DIG_P1              = "\x8E";
const      BME280_REGISTER_DIG_P2              = "\x90";
const      BME280_REGISTER_DIG_P3              = "\x92";
const      BME280_REGISTER_DIG_P4              = "\x94";
const      BME280_REGISTER_DIG_P5              = "\x96";
const      BME280_REGISTER_DIG_P6              = "\x98";
const      BME280_REGISTER_DIG_P7              = "\x9A";
const      BME280_REGISTER_DIG_P8              = "\x9C";
const      BME280_REGISTER_DIG_P9              = "\x9E";
const      BME280_REGISTER_DIG_H1              = "\xA1";
const      BME280_REGISTER_DIG_H2              = "\xE1";
const      BME280_REGISTER_DIG_H3              = "\xE3";
const      BME280_REGISTER_DIG_H4              = "\xE4";
const      BME280_REGISTER_DIG_H5              = "\xE5";
const      BME280_REGISTER_DIG_H6              = "\xE7";
const      BME280_REGISTER_CHIPID             = "\xD0";
const      BME280_REGISTER_VERSION            = "\xD1";

// register command values are supposed to be "\x00" formatted according to TSL2561 example
const      BME280_REGISTER_SOFTRESET          = "\xE0";
const      BME280_REGISTER_CAL26              = "\xE1";  // R calibration stored in 0xE1-0xF0
const      BME280_REGISTER_CONTROLHUMID       = "\xF2";
const      BME280_REGISTER_CHIPID             = "\xD0";
const      BME280_REGISTER_CONTROL            = "\xF4";
const      BME280_REGISTER_CONFIG             = "\xF5";
const      BME280_REGISTER_PRESSUREDATA       = "\xF7";
const      BME280_REGISTER_TEMPDATA           = "\xFA";
const      BME280_REGISTER_HUMIDDATA          = "\xFD";

const TSL2561_COMMAND_BIT = "\x80";         // Command register. Bit 7 must be 1
const TSL2561_CONTROL_POWERON = "\x03";     // Power on setting
const TSL2561_CONTROL_POWEROFF = "\x00";    // Power off setting
const TSL2561_REGISTER_TIMING = "\x81";     // Access timing register
const TSL2561_REGISTER_ADC0_LSB = "\xAC";   // LSB of sensor's two-byte ADC value
const TSL2561_REGISTER_ADC1_LSB = "\xAE";   // LSB of sensor's two-byte ADC value
const TSL2561_GAIN_LOW_INT_10 = "\x01";     // Gain to low, integration timing to 101ms
const TSL2561_GAIN_LOW_INT_13 = "\x00";     // Gain to low, integration timing to 13.7ms
const TSL2561_GAIN_HI_INT_10 = "\x11";     // Gain to low, integration timing to 101ms
const TSL2561_GAIN_HI_INT_13 = "\x10";     // Gain to low, integration timing to 13.7ms

// Note: Imp i2c_lux address values are integers

const TSL2561_ADDR_LOW = 0x29;              // ADDR pin ground
const TSL2561_ADDR_HIGH = 0x49;             // ADDR pin 3v3
const TSL2561_ADDR_FLOAT = 0x39;            // ADDR pin floating

// Lux calculation constants

const LUX_SCALE = 14;                       // scale by 2^14        
const RATIO_SCALE = 9;                      // scale ratio by 2^9

const B1C = 0x0204;
const M1C = 0x01ad;
const B2C = 0x0228;
const M2C = 0x02c1;
const B3C = 0x0253;
const M3C = 0x0363;
const B4C = 0x0282;
const M4C = 0x03df;
const B5C = 0x0177;
const M5C = 0x01dd;
const B6C = 0x0101;
const M6C = 0x0127;
const B7C = 0x0037;
const M7C = 0x002b;
const B8C = 0x0000;
const M8C = 0x0000;
const K1C = 0x0043;
const K2C = 0x0085;
const K3C = 0x00c8;
const K4C = 0x010a;
const K5C = 0x014d;
const K6C = 0x019a;
const K7C = 0x029a;
const K8C = 0x029a;

t_fine <- 0.00;

function write8(REG_ADDR, REG_VAL) {
	i2c.write(i2cAddr, REG_ADDR);
	i2c.write(i2cAddr, REG_VAL);
}

function read16(REG_ADDR) {
	//server.log("I2C read error: " + i2c.readerror());
    local word = i2c.read(i2cAddr, REG_ADDR, 2);
    // local intVal = hexStringToInt(word);
    // server.log("intVal =" + intVal);
    local REG_VAL = (word[0] << 8) + word[1];
    //server.log(REG_VAL);
    return REG_VAL;
}

// read16 little endian
function read16_LE(REG_ADDR) {
	//server.log("I2C read error: " + i2c.readerror());
    local word = i2c.read(i2cAddr, REG_ADDR, 2);
    // local intVal = hexStringToInt(word);
    // server.log("intVal =" + intVal);
    local REG_VAL = (word[1] << 8 ) + word[0];
    //server.log(REG_VAL);
    return REG_VAL;
}

function read8(REG_ADDR) {
	//server.log("I2C read error: " + i2c.readerror());
    local word = i2c.read(i2cAddr, REG_ADDR, 1);
    // local intVal = hexStringToInt(word);
    // server.log("intVal =" + intVal);
    local REG_VAL = word[0];
    //server.log(REG_VAL);
    return REG_VAL;
}

function readCoefficients(){

	cal_t1 <- read16_LE(BME280_REGISTER_DIG_T1);
	cal_t2 <- read16_LE(BME280_REGISTER_DIG_T2);     
	cal_t3 <- read16_LE(BME280_REGISTER_DIG_T3);     
	cal_p1 <- read16_LE(BME280_REGISTER_DIG_P1);     
	cal_p2 <- read16_LE(BME280_REGISTER_DIG_P2);     
	cal_p3 <- read16_LE(BME280_REGISTER_DIG_P3);     
	cal_p4 <- read16_LE(BME280_REGISTER_DIG_P4);     
	cal_p5 <- read16_LE(BME280_REGISTER_DIG_P5);     
	cal_p6 <- read16_LE(BME280_REGISTER_DIG_P6);     
	cal_p7 <- read16_LE(BME280_REGISTER_DIG_P7);     
	cal_p8 <- read16_LE(BME280_REGISTER_DIG_P8);    
	cal_p9 <- read16_LE(BME280_REGISTER_DIG_P9);     
	cal_h1 <- read8(BME280_REGISTER_DIG_H1);     
	cal_h2 <- read16_LE(BME280_REGISTER_DIG_H2);     
	cal_h3 <- read8(BME280_REGISTER_DIG_H3);     
	cal_h4 <- (read8(BME280_REGISTER_DIG_H4) << 4) | (read8(BME280_REGISTER_DIG_H4+1) & 0xF); 
	cal_h5 <- (read8(BME280_REGISTER_DIG_H5+1) << 4) | (read8(BME280_REGISTER_DIG_H5) >> 4);
	cal_h6 <- read8(BME280_REGISTER_DIG_H6);             
}

function readTemperature() {
	
	local var1, var2;
	local adc_T = read16(BME280_REGISTER_TEMPDATA);
	//server.log("adc_T" + adc_T);
	adc_T = adc_T << 8;
	//server.log("preopAdcVal" + (adc_T));
    adc_T = adc_T | read8(BME280_REGISTER_TEMPDATA+2);
    //server.log ("read8val = " + read8(BME280_REGISTER_TEMPDATA+2));
    adc_T = adc_T >> 4;
    //server.log("postopadc_T " + adc_T);
  	var1  = (((adc_T>>3) - (cal_t1 << 1))  
	* (cal_t2)) >> 11;  //cal_t2 is a read16S_LE in arduino
    // server.log ("result = " + var1); //all math should be correct up to this point 

    var2  = (((((adc_T>>4) - (cal_t1)) * 
	     ((adc_T>>4) - (cal_t1))) >> 12)
	     * 
	   (cal_t3)) >> 14;
    

    ::t_fine = var1 + var2;
    
    // server.log("t_fine = " + ::t_fine);

    local T  = (t_fine * 5 + 128) >> 8;
    local cast = T.tofloat();
    server.log("temp:" + (cast/100));
    return cast/100;
}

function readHumidity() {

  local adc_H = read16(BME280_REGISTER_HUMIDDATA);
  
  local v_x1_u32r;
  
  v_x1_u32r = (::t_fine - 76800);
  
//   server.log ("t_fine = " + v_x1_u32r);
  
  //server.log ("t fine : " + v_x1_u32r);

  v_x1_u32r = (((((adc_H << 14) - (cal_h4 << 20) - 
		  (cal_h5 * v_x1_u32r)) + 16384) >> 15) 
		  *
    (((((v_x1_u32r * cal_h6) >> 10)
        * ((v_x1_u32r * cal_h3) >> 11) + 32768) >> 10) 
        + (2097152 * (cal_h2 + 8192)) >> 14));
 
  v_x1_u32r = (v_x1_u32r - (((((v_x1_u32r >> 15) * (v_x1_u32r >> 15)) >> 7) * 
			     cal_h1) >> 4));

  v_x1_u32r = (v_x1_u32r < 0) ? 0 : v_x1_u32r; 
  v_x1_u32r = (v_x1_u32r > 419430400) ? 419430400 : v_x1_u32r;
  v_x1_u32r = v_x1_u32r>>12; 
  local h = v_x1_u32r;
  local cast_h = h.tofloat();
  server.log("humidity: " + (cast_h / 1024.0));
  return  cast_h / 1024.0;
}

function calculateLux(ch0, ch1) {
	// Calculate the luminosity based on ADC Channel 0 (visible + IR) and 
	// Channel 1 (IR) values. Returns the luminosity. Assumes sensor 
	// integration time is 13ms, gain is 16x
	
	local chScale = 29975;
	local channel0 = (ch0 * chScale) >> 10;
	local channel1 = (ch1 * chScale) >> 10;
	local ratio1 = 0;
	
	if (channel0 != 0) ratio1 = (channel1 << (RATIO_SCALE + 1)) / channel0;
	
	// Round the ratio value
	local ratio = (ratio1 + 1) >> 1;
	local b = 0;
	local m = 0;
	
	if ((ratio >= 0) && (ratio <= K1C))
	{b=B1C; m=M1C;}
	else if (ratio <= K2C)
	{b=B2C; m=M2C;}
	else if (ratio <= K3C)
	{b=B3C; m=M3C;}
	else if (ratio <= K4C)
	{b=B4C; m=M4C;}	
	else if (ratio <= K5C)
	{b=B5C; m=M5C;}
	else if (ratio <= K6C)
	{b=B6C; m=M6C;}
	else if (ratio <= K7C)
	{b=B7C; m=M7C;}	
	else if (ratio > K8C)
	{b=B8C; m=M8C;}
	
	local temp = ((channel0 * b) - (channel1 * m));
	
	// Do not allow a negative lux value
	if (temp < 0) temp = 0;
	temp += (1 << (LUX_SCALE - 1));
	
	// Strip off fractional portion
	local lux = temp >> LUX_SCALE;
	return lux;
}

function readSensorAdc0() {
    // server.log("i2c_lux read error: " + i2c_lux.readerror());
    local word = i2c_lux.read(i2c_luxAddr, TSL2561_REGISTER_ADC0_LSB, 2);
    local lumo = (word[1] << 8) + word[0];
    return lumo;
}

function readSensorAdc1() {
    local word = i2c_lux.read(i2c_luxAddr, TSL2561_REGISTER_ADC1_LSB, 2);
    local lumo = (word[1] << 8) + word[0];
    return lumo;
}

function getLumo(boolValue) {
    if (boolValue) {
        // Set command focus to ADC 0
        i2c_lux.write(i2c_luxAddr, TSL2561_REGISTER_ADC0_LSB);
        local lumo0 = readSensorAdc0();
        server.log("Light level: " + lumo0);
        
        i2c_lux.write(i2c_luxAddr, TSL2561_REGISTER_ADC1_LSB);
        local lumo1 = readSensorAdc1();
        server.log("IR level: " + lumo1);
        
        local lux = calculateLux(lumo0, lumo1);
        server.log("Lux: " + lux);
        // local data = { "Light level: ": lumo0, "IR Level: ": lumo1, "Lux: ": lux}
        // agent.send("sendData", data);
    }
}

function readSensors() {
    readTemperature();
    readHumidity();
    getLumo(true);
}

// Set up alias for i2c and set bus to 100kHz
i2c <- hardware.i2c12;
i2c.configure(CLOCK_SPEED_10_KHZ);
i2c_lux <- hardware.i2c89;
i2c_lux.configure(CLOCK_SPEED_100_KHZ);

// Set sensor's address by shifting 7-bit address 1 bit leftward as per imp I2C spec
i2cAddr <- BME280_ADDRESS << 1;
i2c_luxAddr <- TSL2561_ADDR_FLOAT << 1;                                

// Set command focus to the control register
i2c.write(i2cAddr, BME280_REGISTER_CONTROL); 
i2c_lux.write(i2c_luxAddr, TSL2561_COMMAND_BIT);  
write8(BME280_REGISTER_CONTROL, "\x3F");
// write8(BME280_REGISTER_CONTROLHUMID, "\x03");
i2c.write(i2cAddr, BME280_REGISTER_CONTROL);
local result = i2c.write(i2cAddr, BME280_REGISTER_CONTROL + "\x3F");
i2c_lux.write(i2c_luxAddr, TSL2561_CONTROL_POWERON);

// Issue command: write (0x80) to the timing register (0x01)
// ie. TSL2561_REGISTER_TIMING = 0x81
i2c_lux.write(i2c_luxAddr, TSL2561_REGISTER_TIMING);

// Set gain to low by writing a byte to the timing register
// bit 4 to the gain: 1 or 0 (gain high or low)
// bits 1,0 to the integration timing: 0,0 or 1,0 (timing 13.7ms or 101ms)
i2c_lux.write(i2c_luxAddr, TSL2561_GAIN_LOW_INT_10);


readCoefficients();

readSensors();

imp.onidle(function(){ server.sleepfor(5); });

